<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IndustrialVision ‚Äî Live Factory Floor</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Barlow+Condensed:wght@600;700;800&family=Barlow:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0f1923;
  --panel: #111d2b;
  --panel2: #162234;
  --border: #1e3450;
  --border2: #1a2e48;
  --accent: #ff4d1a;
  --accent2: #1a9fff;
  --green: #00e676;
  --yellow: #ffd600;
  --purple: #c471ed;
  --text: #e8f4ff;
  --text2: #b0cce8;
  --muted: #4a7090;
  --shadow: rgba(0,20,50,0.5);
  --glow-blue: rgba(26,159,255,0.15);
  --glow-red: rgba(255,77,26,0.15);
  --glow-green: rgba(0,230,118,0.15);
}
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;background:var(--bg);font-family:'Barlow',sans-serif;color:var(--text);}
#c{display:block;width:100%;height:100%;}

/* ‚îÄ‚îÄ TOP BAR ‚îÄ‚îÄ */
#topbar{
  position:fixed;top:0;left:0;right:0;z-index:20;
  height:60px;
  background:var(--panel);
  border-bottom:2px solid var(--accent2);
  display:flex;align-items:center;
  padding:0 20px;gap:20px;
  box-shadow:0 4px 30px rgba(26,159,255,0.18);
}
.brand{display:flex;align-items:center;gap:12px;flex-shrink:0;}
.brand-logo{
  width:38px;height:38px;
  background:linear-gradient(135deg,var(--accent2),#0055aa);
  clip-path:polygon(20% 0%,80% 0%,100% 50%,80% 100%,20% 100%,0% 50%);
  display:flex;align-items:center;justify-content:center;
  box-shadow:0 0 20px rgba(26,159,255,0.5);
  animation:logoGlow 3s ease-in-out infinite;
}
@keyframes logoGlow{0%,100%{box-shadow:0 0 18px rgba(26,159,255,0.4);}50%{box-shadow:0 0 36px rgba(26,159,255,0.8);}}
.brand-logo::after{content:'';width:14px;height:14px;background:#fff;clip-path:polygon(20% 0%,80% 0%,100% 50%,80% 100%,20% 100%,0% 50%);opacity:0.9;}
.brand-text{font-family:'Barlow Condensed',sans-serif;font-size:20px;font-weight:800;letter-spacing:3px;color:#fff;text-shadow:0 0 20px rgba(26,159,255,0.6);}
.brand-sub{font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:2px;margin-top:-2px;text-transform:uppercase;}
.divider{width:1px;height:34px;background:var(--border);flex-shrink:0;}

/* Stat pills */
.stat-row{display:flex;gap:8px;align-items:center;}
.stat-pill{
  display:flex;align-items:center;gap:10px;
  padding:7px 14px;border-radius:4px;
  border:1px solid;
  background:rgba(15,25,35,0.8);
  position:relative;overflow:hidden;
}
.stat-pill::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;}
.stat-pill.blue{border-color:rgba(26,159,255,0.4);}.stat-pill.blue::before{background:var(--accent2);}
.stat-pill.red{border-color:rgba(255,77,26,0.4);}.stat-pill.red::before{background:var(--accent);}
.stat-pill.green{border-color:rgba(0,230,118,0.4);}.stat-pill.green::before{background:var(--green);}
.stat-pill.yellow{border-color:rgba(255,214,0,0.4);}.stat-pill.yellow::before{background:var(--yellow);}
.sp-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0;}
.sp-num{font-family:'JetBrains Mono',monospace;font-size:18px;font-weight:700;line-height:1;}
.sp-lbl{font-family:'Barlow Condensed',monospace;font-size:10px;color:var(--muted);letter-spacing:1.5px;text-transform:uppercase;}
.live-badge{
  display:flex;align-items:center;gap:6px;
  font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:600;color:var(--green);
  background:rgba(0,230,118,0.08);border:1px solid rgba(0,230,118,0.3);
  padding:5px 12px;border-radius:3px;margin-left:auto;
  text-shadow:0 0 10px rgba(0,230,118,0.6);
}
.live-dot{width:7px;height:7px;border-radius:50%;background:var(--green);box-shadow:0 0 8px var(--green);animation:pulse 1.2s infinite;}
@keyframes pulse{0%,100%{opacity:1;transform:scale(1);}50%{opacity:.3;transform:scale(0.7);}}
#clock-display{font-family:'JetBrains Mono',monospace;font-size:13px;font-weight:600;color:var(--text2);}

/* ‚îÄ‚îÄ RIGHT PANEL ‚îÄ‚îÄ */
#right-panel{
  position:fixed;right:0;top:60px;bottom:0;width:310px;z-index:15;
  background:var(--panel);
  border-left:2px solid var(--border);
  display:flex;flex-direction:column;
  overflow:hidden;
}
.rp-section{border-bottom:1px solid var(--border2);padding:14px 16px;flex-shrink:0;}
.rp-title{
  font-family:'Barlow Condensed',sans-serif;font-size:11px;font-weight:700;
  letter-spacing:3px;text-transform:uppercase;
  color:var(--accent2);margin-bottom:12px;
  display:flex;align-items:center;gap:8px;
}
.rp-title::before{content:'';display:inline-block;width:3px;height:14px;background:var(--accent2);border-radius:2px;}

/* Machine status grid */
.machine-grid{display:grid;grid-template-columns:1fr 1fr;gap:7px;}
.machine-card{
  border:1px solid var(--border2);
  background:var(--panel2);border-radius:5px;
  padding:10px 11px;
  transition:all 0.25s;
  position:relative;overflow:hidden;
}
.machine-card::after{content:'';position:absolute;bottom:0;left:0;right:0;height:2px;background:var(--green);transition:background 0.3s;}
.machine-card.has-fault{border-color:rgba(255,77,26,0.5);background:rgba(255,77,26,0.06);}
.machine-card.has-fault::after{background:var(--accent);}
.mc-id{font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:2px;text-transform:uppercase;}
.mc-name{font-size:12px;font-weight:600;line-height:1.3;margin:3px 0;color:var(--text);}
.mc-faults{font-family:'JetBrains Mono',monospace;font-size:12px;font-weight:700;}

/* Status indicator dot */
.mc-status{display:flex;align-items:center;gap:5px;margin-bottom:4px;}
.mc-dot{width:6px;height:6px;border-radius:50%;background:var(--green);box-shadow:0 0 6px var(--green);}
.machine-card.has-fault .mc-dot{background:var(--accent);box-shadow:0 0 6px var(--accent);}

/* Defect log */
#defect-log{flex:1;overflow-y:auto;padding:10px 14px;}
#defect-log::-webkit-scrollbar{width:4px;}
#defect-log::-webkit-scrollbar-track{background:var(--panel);}
#defect-log::-webkit-scrollbar-thumb{background:var(--border);border-radius:2px;}
.defect-card{
  border:1px solid var(--border2);
  border-left:3px solid var(--accent);
  background:var(--panel2);
  border-radius:4px;
  padding:10px 12px;
  margin-bottom:7px;
  animation:fadeSlide .3s ease;
  position:relative;
}
.defect-card::before{content:'FAULT';position:absolute;top:8px;right:10px;font-family:'JetBrains Mono',monospace;font-size:8px;font-weight:700;color:var(--accent);letter-spacing:1px;opacity:0.6;}
@keyframes fadeSlide{from{opacity:0;transform:translateY(-10px);}to{opacity:1;transform:none;}}
.dc-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;}
.dc-machine{font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--accent2);font-weight:600;}
.dc-time{font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--muted);}
.dc-type{font-size:13px;font-weight:700;letter-spacing:0.5px;}
.dc-desc{font-size:11px;color:var(--text2);margin-top:3px;}
.dc-scanner{font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--muted);margin-top:5px;letter-spacing:0.5px;}
.empty-log{padding:28px 0;text-align:center;font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--muted);line-height:1.8;}

/* ‚îÄ‚îÄ BOTTOM BAR ‚îÄ‚îÄ */
#bottom-bar{
  position:fixed;bottom:0;left:0;right:310px;z-index:20;
  height:56px;
  background:var(--panel);
  border-top:2px solid var(--border);
  display:flex;align-items:center;padding:0 20px;gap:12px;
  box-shadow:0 -4px 24px rgba(0,20,50,0.4);
}
.ctrl-btn{
  padding:8px 18px;border-radius:4px;
  font-family:'Barlow Condensed',sans-serif;font-size:13px;font-weight:700;
  cursor:pointer;letter-spacing:1.5px;text-transform:uppercase;
  border:2px solid;transition:all .15s;
}
.btn-primary{border-color:var(--accent2);color:var(--accent2);background:transparent;}
.btn-primary:hover{background:var(--accent2);color:#fff;box-shadow:0 0 20px rgba(26,159,255,0.5);}
.btn-danger{border-color:var(--accent);color:var(--accent);background:transparent;}
.btn-danger:hover{background:var(--accent);color:#fff;box-shadow:0 0 20px rgba(255,77,26,0.5);}
.btn-success{border-color:var(--green);color:var(--green);background:transparent;}
.btn-success:hover{background:var(--green);color:#000;box-shadow:0 0 20px rgba(0,230,118,0.5);}
.ctrl-group{display:flex;align-items:center;gap:8px;}
.ctrl-label{font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--muted);letter-spacing:1.5px;text-transform:uppercase;}
.ctrl-val{font-family:'JetBrains Mono',monospace;font-size:13px;font-weight:700;color:var(--text);min-width:32px;}
input[type=range]{
  width:90px;height:4px;
  -webkit-appearance:none;appearance:none;
  background:var(--border);border-radius:2px;cursor:pointer;
}
input[type=range]::-webkit-slider-thumb{
  -webkit-appearance:none;appearance:none;
  width:16px;height:16px;border-radius:50%;
  background:var(--accent2);border:2px solid var(--panel);
  box-shadow:0 0 8px rgba(26,159,255,0.6);
}
.hint{font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--muted);margin-left:auto;letter-spacing:0.5px;}

/* Fault badge in topbar */
#fault-badge{
  padding:5px 12px;border-radius:4px;
  font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:700;
  background:rgba(255,77,26,0.12);
  border:1px solid rgba(255,77,26,0.4);
  color:var(--accent);
  text-shadow:0 0 8px rgba(255,77,26,0.4);
}
</style>
</head>
<body>

<!-- TOP BAR -->
<div id="topbar">
  <div class="brand">
    <div class="brand-logo"></div>
    <div>
      <div class="brand-text">INDUSTRIALVISION</div>
      <div class="brand-sub">Factory Monitoring System v3.2</div>
    </div>
  </div>
  <div class="divider"></div>
  <div class="stat-row">
    <div class="stat-pill blue">
      <div class="sp-dot" style="background:var(--accent2);box-shadow:0 0 8px var(--accent2);"></div>
      <div><div class="sp-num" id="h-scan" style="color:var(--accent2)">0</div><div class="sp-lbl">Inspected</div></div>
    </div>
    <div class="stat-pill red">
      <div class="sp-dot" style="background:var(--accent);box-shadow:0 0 8px var(--accent);"></div>
      <div><div class="sp-num" id="h-def" style="color:var(--accent)">0</div><div class="sp-lbl">Defects</div></div>
    </div>
    <div class="stat-pill green">
      <div class="sp-dot" style="background:var(--green);box-shadow:0 0 8px var(--green);"></div>
      <div><div class="sp-num" id="h-pass" style="color:var(--green)">0</div><div class="sp-lbl">Passed</div></div>
    </div>
    <div class="stat-pill yellow">
      <div class="sp-dot" style="background:var(--yellow);box-shadow:0 0 8px var(--yellow);"></div>
      <div><div class="sp-num" id="h-rate" style="color:var(--yellow)">‚Äî</div><div class="sp-lbl">Fault Rate</div></div>
    </div>
  </div>
  <div class="divider"></div>
  <span id="fault-badge">0 active faults</span>
  <div class="live-badge"><div class="live-dot"></div>LIVE</div>
  <span id="clock-display"></span>
</div>

<!-- RIGHT PANEL -->
<div id="right-panel">
  <div class="rp-section">
    <div class="rp-title">Machine Status</div>
    <div class="machine-grid" id="machine-grid"></div>
  </div>
  <div class="rp-section" style="padding-bottom:8px;">
    <div class="rp-title">Inspection Log</div>
  </div>
  <div id="defect-log"><div class="empty-log">System nominal.<br>Awaiting inspection data.</div></div>
</div>

<!-- BOTTOM BAR -->
<div id="bottom-bar">
  <button class="ctrl-btn btn-primary" id="tog" onclick="toggleSim()">‚è∏ PAUSE</button>
  <button class="ctrl-btn btn-danger" onclick="injectFault()">‚ö† INJECT FAULT</button>
  <button class="ctrl-btn btn-success" onclick="resetSim()">‚Ü∫ RESET</button>
  <div class="divider" style="height:28px;"></div>
  <div class="ctrl-group">
    <span class="ctrl-label">SPEED</span>
    <input type="range" id="spd" min="1" max="6" value="2">
    <span class="ctrl-val" id="spd-v">2√ó</span>
  </div>
  <div class="ctrl-group">
    <span class="ctrl-label">FAULT RATE</span>
    <input type="range" id="frt" min="5" max="70" value="28">
    <span class="ctrl-val" id="frt-v">28%</span>
  </div>
  <span class="hint">üñ± Drag to orbit ¬∑ Scroll to zoom ¬∑ Right-drag to pan &nbsp;|&nbsp; üî∂ Shapes transform at each machine ‚Üí ü§ñ Robot arm removes defects</span>
</div>

<canvas id="c"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// RENDERER
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('c'),antialias:true,alpha:false});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.outputEncoding = THREE.sRGBEncoding;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a1422);
scene.fog = new THREE.Fog(0x0a1422, 38, 85);

const camera = new THREE.PerspectiveCamera(50,1,0.1,300);
camera.position.set(0,22,35);
camera.lookAt(0,3,0);

function onResize(){
  const W=window.innerWidth-300, H=window.innerHeight-56;
  renderer.setSize(W,H);
  camera.aspect=W/H;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize',onResize);
onResize();

// Orbit + Pan
let drag=false, panDrag=false;
let lastMX=0, lastMY=0;
let camTheta=0.05, camPhi=0.42, camR=35;
const camTarget = new THREE.Vector3(0,3,0);

const cvs = document.getElementById('c');
cvs.addEventListener('mousedown',e=>{
  if(e.button===2){panDrag=true;}else{drag=true;}
  lastMX=e.clientX;lastMY=e.clientY;
  e.preventDefault();
});
window.addEventListener('mouseup',()=>{drag=false;panDrag=false;});
window.addEventListener('contextmenu',e=>e.preventDefault());
window.addEventListener('mousemove',e=>{
  if(drag){
    camTheta-=(e.clientX-lastMX)*0.004;
    camPhi=Math.max(0.08,Math.min(1.38,camPhi-(e.clientY-lastMY)*0.004));
  }
  if(panDrag){
    const right=new THREE.Vector3(Math.cos(camTheta),0,-Math.sin(camTheta));
    const up=new THREE.Vector3(0,1,0);
    camTarget.addScaledVector(right,(e.clientX-lastMX)*-0.02);
    camTarget.addScaledVector(up,(e.clientY-lastMY)*0.02);
  }
  lastMX=e.clientX;lastMY=e.clientY;
});
window.addEventListener('wheel',e=>{camR=Math.max(6,Math.min(60,camR+e.deltaY*0.03));});
cvs.addEventListener('touchstart',e=>{drag=true;lastMX=e.touches[0].clientX;lastMY=e.touches[0].clientY;},{passive:true});
cvs.addEventListener('touchend',()=>drag=false,{passive:true});
cvs.addEventListener('touchmove',e=>{
  if(!drag)return;
  camTheta-=(e.touches[0].clientX-lastMX)*0.005;
  camPhi=Math.max(0.08,Math.min(1.38,camPhi-(e.touches[0].clientY-lastMY)*0.005));
  lastMX=e.touches[0].clientX;lastMY=e.touches[0].clientY;
},{passive:true});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// LIGHTS ‚Äî bright factory daylight
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Vivid dark factory ‚Äî deep blue ambient + strong key light
scene.add(new THREE.AmbientLight(0x1a3060, 4.5));

// Main key light ‚Äî cool industrial arc
const sunLight = new THREE.DirectionalLight(0xd0e8ff, 2.8);
sunLight.position.set(10,30,15);
sunLight.castShadow=true;
sunLight.shadow.mapSize.set(4096,4096);
sunLight.shadow.camera.left=-40; sunLight.shadow.camera.right=40;
sunLight.shadow.camera.top=30; sunLight.shadow.camera.bottom=-30;
sunLight.shadow.camera.far=100;
sunLight.shadow.bias=-0.0003;
scene.add(sunLight);

// Warm fill ‚Äî simulates reflected factory floor glow
const fillA = new THREE.DirectionalLight(0xffa040,0.6);
fillA.position.set(-15,8,-10);
scene.add(fillA);
const fillB = new THREE.DirectionalLight(0x4080ff,0.4);
fillB.position.set(5,5,20);
scene.add(fillB);

// Bright fluorescent ceiling strips
const ceilLights=[];
for(let x=-12;x<=12;x+=6){
  for(let z=-2;z<=2;z+=4){
    const pl=new THREE.PointLight(0xc8deff,2.2,22,1.2);
    pl.position.set(x,11,z);
    scene.add(pl);
    ceilLights.push(pl);
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// FACTORY ENVIRONMENT
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚Äî Dark industrial floor with blue-tinted epoxy sheen
const floorCanvas=document.createElement('canvas');
floorCanvas.width=1024;floorCanvas.height=1024;
const fCtx=floorCanvas.getContext('2d');
fCtx.fillStyle='#0d1a28';
fCtx.fillRect(0,0,1024,1024);
// Subtle tile grid
fCtx.strokeStyle='rgba(30,60,100,0.6)';fCtx.lineWidth=2;
for(let i=0;i<1024;i+=64){
  fCtx.beginPath();fCtx.moveTo(i,0);fCtx.lineTo(i,1024);fCtx.stroke();
  fCtx.beginPath();fCtx.moveTo(0,i);fCtx.lineTo(1024,i);fCtx.stroke();
}
// Gloss highlights (wet epoxy look)
for(let i=0;i<40;i++){
  const gx=Math.random()*1024,gy=Math.random()*1024;
  const gr=fCtx.createRadialGradient(gx,gy,0,gx,gy,60+Math.random()*80);
  gr.addColorStop(0,'rgba(60,120,200,0.08)');
  gr.addColorStop(1,'rgba(0,0,0,0)');
  fCtx.fillStyle=gr;fCtx.fillRect(0,0,1024,1024);
}
// Scuff/wear marks
fCtx.strokeStyle='rgba(20,40,70,0.4)';fCtx.lineWidth=3;
for(let i=0;i<20;i++){
  fCtx.beginPath();
  const sx=Math.random()*1024,sy=Math.random()*1024;
  fCtx.moveTo(sx,sy);fCtx.lineTo(sx+Math.random()*80-40,sy+Math.random()*80-40);
  fCtx.stroke();
}
const floorTex=new THREE.CanvasTexture(floorCanvas);
floorTex.wrapS=floorTex.wrapT=THREE.RepeatWrapping;
floorTex.repeat.set(10,8);
const floor=new THREE.Mesh(
  new THREE.PlaneGeometry(100,70),
  new THREE.MeshStandardMaterial({map:floorTex,roughness:0.28,metalness:0.25,color:0xffffff})
);
floor.rotation.x=-Math.PI/2;floor.position.y=-0.01;floor.receiveShadow=true;
scene.add(floor);

// Yellow safety lines
function safetyLine(x1,z1,x2,z2,w=0.15){
  const dx=x2-x1,dz=z2-z1;
  const len=Math.sqrt(dx*dx+dz*dz);
  const angle=Math.atan2(dz,dx);
  const m=new THREE.Mesh(
    new THREE.PlaneGeometry(len,w),
    new THREE.MeshStandardMaterial({color:0xffcc00,roughness:0.8,metalness:0.1})
  );
  m.rotation.x=-Math.PI/2;m.rotation.z=-angle;
  m.position.set((x1+x2)/2,0.005,(z1+z2)/2);
  scene.add(m);
}
for(let x=-18;x<=18;x+=1.5){safetyLine(x,3.5,x+0.7,3.5);}
for(let x=-18;x<=18;x+=1.5){safetyLine(x,-3.5,x+0.7,-3.5);}
for(let x=-18;x<=18;x+=1.5){safetyLine(x,8,x+0.7,8);}
for(let x=-18;x<=18;x+=1.5){safetyLine(x,-8,x+0.7,-8);}

// ‚Äî Ceiling structure
const ceilMat=new THREE.MeshStandardMaterial({color:0x0a1520,roughness:0.9,metalness:0.1});
// Structural beams
const beamMat=new THREE.MeshStandardMaterial({color:0x1a2e44,roughness:0.55,metalness:0.8});
for(let x=-20;x<=20;x+=8){
  // Column
  const col=new THREE.Mesh(new THREE.BoxGeometry(0.4,12,0.4),
    new THREE.MeshStandardMaterial({color:0x1e3050,roughness:0.5,metalness:0.8}));
  col.position.set(x,6,-10);col.castShadow=true;scene.add(col);
  const col2=new THREE.Mesh(new THREE.BoxGeometry(0.4,12,0.4),
    new THREE.MeshStandardMaterial({color:0x1e3050,roughness:0.5,metalness:0.8}));
  col2.position.set(x,6,10);col2.castShadow=true;scene.add(col2);
  // Ceiling beam
  const cBeam=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.55,22),beamMat);
  cBeam.position.set(x,12.2,0);scene.add(cBeam);
}
// Longitudinal purlins
for(let z=-6;z<=6;z+=3){
  const purlin=new THREE.Mesh(new THREE.BoxGeometry(42,0.2,0.2),beamMat);
  purlin.position.set(0,11.9,z);scene.add(purlin);
}

// Fluorescent light fixtures on ceiling ‚Äî bright white tubes
ceilLights.forEach((pl,i)=>{
  const fix=new THREE.Mesh(
    new THREE.BoxGeometry(3.0,0.1,0.32),
    new THREE.MeshStandardMaterial({color:0xd0e8ff,emissive:0xb0d4ff,emissiveIntensity:2.5,roughness:0.1})
  );
  fix.position.copy(pl.position);fix.position.y=11.8;
  scene.add(fix);
  // Reflector housing
  const housing=new THREE.Mesh(new THREE.BoxGeometry(3.1,0.18,0.42),
    new THREE.MeshStandardMaterial({color:0x1e3050,roughness:0.4,metalness:0.8}));
  housing.position.copy(pl.position);housing.position.y=11.88;
  scene.add(housing);
  const brkt=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.4,0.05),
    new THREE.MeshStandardMaterial({color:0x2a4060,roughness:0.5,metalness:0.9}));
  brkt.position.copy(pl.position);brkt.position.y=12.1;
  scene.add(brkt);
});

// Back wall ‚Äî dark corrugated steel
const wallMat=new THREE.MeshStandardMaterial({color:0x0e1c2e,roughness:0.8,metalness:0.15});
const backWall=new THREE.Mesh(new THREE.PlaneGeometry(80,18),wallMat);
backWall.position.set(0,9,-12);backWall.receiveShadow=true;scene.add(backWall);
// Corrugated panel lines
for(let px=-20;px<=20;px+=2){
  const pnl=new THREE.Mesh(new THREE.BoxGeometry(0.05,18,0.04),
    new THREE.MeshStandardMaterial({color:0x162438,roughness:0.6,metalness:0.6}));
  pnl.position.set(px,9,-11.97);scene.add(pnl);
}
// Wainscot
const wain=new THREE.Mesh(new THREE.PlaneGeometry(80,2),
  new THREE.MeshStandardMaterial({color:0x0a1828,roughness:0.75,metalness:0.2}));
wain.position.set(0,1,-11.98);scene.add(wain);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// CONVEYOR BELT SYSTEM
// Two parallel production lines!
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const BELT_LEN = 26;
const BELT_W   = 1.8;
const BELT_Y   = 1.05;  // belt surface height

// We'll have 2 lines: z offsets
const LINE_Z = [3.0, -3.0];  // front and back
const LINE_COLORS = [0x2a6fad, 0xc8401a]; // accent colors per line

// Materials
const steelFrameMat = new THREE.MeshStandardMaterial({color:0x2a4060,roughness:0.4,metalness:0.88});
const steelDarkMat  = new THREE.MeshStandardMaterial({color:0x1e3050,roughness:0.45,metalness:0.92});
const rubberMat     = new THREE.MeshStandardMaterial({color:0x181412,roughness:0.97,metalness:0.02});
const shaftMat2     = new THREE.MeshStandardMaterial({color:0x6080a0,roughness:0.2, metalness:0.98});
const rollerMat2    = new THREE.MeshStandardMaterial({color:0x3a5878,roughness:0.28,metalness:0.95});
const rollerEndMat2 = new THREE.MeshStandardMaterial({color:0x4a6888,roughness:0.22,metalness:0.98});

// Belt canvas textures for each line
const beltTextures=[];
const beltOffsets=[0,0];
function makeBeltTex(idx){
  const bc=document.createElement('canvas');
  bc.width=1024;bc.height=256;
  const bx=bc.getContext('2d');
  function redraw(offset){
    bx.fillStyle='#201c18';bx.fillRect(0,0,1024,256);
    // Rubber grain
    for(let i=0;i<3000;i++){
      const px=Math.random()*1024,py=Math.random()*256;
      const v=Math.floor(Math.random()*20+10);
      bx.fillStyle=`rgba(${v},${v-2},${v-3},0.3)`;
      bx.fillRect(px,py,Math.random()*3+1,Math.random()*2+1);
    }
    // Cleats (transverse ribs every ~80px)
    const spacing=80;
    bx.fillStyle='rgba(55,48,40,1)';
    for(let cx=-(spacing)+(offset%spacing);cx<1024+spacing;cx+=spacing){
      bx.fillRect(cx,6,12,244);
      // Cleat detail (lighter top edge)
      bx.fillStyle='rgba(75,65,55,0.7)';
      bx.fillRect(cx,6,12,4);
      bx.fillStyle='rgba(55,48,40,1)';
    }
    // Belt centerline (alignment guide strip)
    bx.fillStyle='rgba(120,100,70,0.3)';
    bx.fillRect(0,120,1024,16);
    // Edge wear bands
    const eg=bx.createLinearGradient(0,0,0,256);
    eg.addColorStop(0,'rgba(100,85,65,0.6)');
    eg.addColorStop(0.12,'rgba(0,0,0,0)');
    eg.addColorStop(0.88,'rgba(0,0,0,0)');
    eg.addColorStop(1,'rgba(100,85,65,0.6)');
    bx.fillStyle=eg;bx.fillRect(0,0,1024,256);
    bTex.needsUpdate=true;
  }
  const bTex=new THREE.CanvasTexture(bc);
  bTex.wrapS=THREE.RepeatWrapping;
  beltTextures.push({tex:bTex,redraw,canvas:bc,ctx:bx});
}
makeBeltTex(0);makeBeltTex(1);

// Roller group storage for animation
const allRollers=[[],[]];
const allPulleys=[[],[]];

function buildConveyorLine(lineIdx){
  const lz=LINE_Z[lineIdx];
  const lcolor=LINE_COLORS[lineIdx];
  const rollers=allRollers[lineIdx];

  // ‚îÄ‚îÄ C-channel side frames (2 sides)
  [-1,1].forEach(side=>{
    const fz=lz+side*(BELT_W/2+0.14);
    // Top flange
    const tf=new THREE.Mesh(new THREE.BoxGeometry(BELT_LEN,0.1,0.25),steelFrameMat);
    tf.position.set(0,BELT_Y+0.28,fz);tf.castShadow=true;tf.receiveShadow=true;scene.add(tf);
    // Web
    const web=new THREE.Mesh(new THREE.BoxGeometry(BELT_LEN,0.3,0.08),steelFrameMat);
    web.position.set(0,BELT_Y+0.12,fz+(side>0?-0.1:0.1));scene.add(web);
    // Bottom flange
    const bf=new THREE.Mesh(new THREE.BoxGeometry(BELT_LEN,0.08,0.22),steelFrameMat);
    bf.position.set(0,BELT_Y-0.04,fz);scene.add(bf);
  });

  // ‚îÄ‚îÄ Crossmembers
  for(let x=-12;x<=12;x+=1.2){
    const xm=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.09,BELT_W+0.28),steelDarkMat);
    xm.position.set(x,BELT_Y+0.15,lz);scene.add(xm);
  }

  // ‚îÄ‚îÄ Support legs (every 3m)
  for(let x=-11;x<=11;x+=4.5){
    [-1,1].forEach(side=>{
      const lz2=lz+side*(BELT_W/2+0.2);
      // Post (box section)
      const post=new THREE.Mesh(new THREE.BoxGeometry(0.12,BELT_Y+0.05,0.12),steelDarkMat);
      post.position.set(x,(BELT_Y+0.05)/2,lz2);post.castShadow=true;scene.add(post);
      // Base plate
      const bp=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.06,0.3),steelFrameMat);
      bp.position.set(x,0.03,lz2);scene.add(bp);
      // Anchor bolts
      [[0.1,0.1],[0.1,-0.1],[-0.1,0.1],[-0.1,-0.1]].forEach(([bx,bz])=>{
        const bolt=new THREE.Mesh(new THREE.CylinderGeometry(0.022,0.022,0.06,6),
          new THREE.MeshStandardMaterial({color:0xa0a8b0,roughness:0.3,metalness:0.98}));
        bolt.position.set(x+bx,0.06,lz2+bz);scene.add(bolt);
      });
      // Diagonal brace
      if(x<11&&side===1){
        const brace=new THREE.Mesh(new THREE.BoxGeometry(4.6,0.06,0.06),steelDarkMat);
        brace.position.set(x+2.25,0.65,lz2);brace.rotation.z=0.12;scene.add(brace);
      }
    });
  }

  // ‚îÄ‚îÄ Rollers ‚Äî precision steel tube
  const rollerSpacing=0.5;
  const nRollers=Math.ceil(BELT_LEN/rollerSpacing)+1;
  for(let ri=0;ri<=nRollers;ri++){
    const rx=-BELT_LEN/2+ri*rollerSpacing;
    const rg=new THREE.Group();
    // Main tube
    const tube=new THREE.Mesh(new THREE.CylinderGeometry(0.095,0.095,BELT_W+0.04,18),rollerMat2);
    tube.rotation.z=Math.PI/2;rg.add(tube);
    // Flanged end caps
    [-1,1].forEach(side=>{
      const cap=new THREE.Mesh(new THREE.CylinderGeometry(0.108,0.108,0.038,14),rollerEndMat2);
      cap.rotation.z=Math.PI/2;cap.position.x=side*(BELT_W/2+0.02);rg.add(cap);
      // Bearing pillow block
      const pb=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.12),steelDarkMat);
      pb.position.set(side*(BELT_W/2+0.14),0,0);rg.add(pb);
      // Grease nipple
      const nip=new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,0.05,6),
        new THREE.MeshStandardMaterial({color:0xcccc44,roughness:0.3,metalness:0.9}));
      nip.rotation.x=Math.PI/2;nip.position.set(side*(BELT_W/2+0.13),0.06,0.04);rg.add(nip);
    });
    // Shaft
    const shaft=new THREE.Mesh(new THREE.CylinderGeometry(0.022,0.022,BELT_W+0.48,7),shaftMat2);
    shaft.rotation.z=Math.PI/2;rg.add(shaft);
    rg.position.set(rx,BELT_Y-0.085,lz);
    scene.add(rg);
    rollers.push(rg);
  }

  // Return rollers (underside)
  for(let ri=0;ri<=7;ri++){
    const rx=-BELT_LEN/2+ri*(BELT_LEN/7);
    const rr=new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.07,BELT_W-0.06,14),rollerMat2);
    rr.rotation.z=Math.PI/2;rr.position.set(rx,0.52,lz);scene.add(rr);
  }

  // ‚îÄ‚îÄ Drive pulleys (large crowned drums at ends)
  [-1,1].forEach(side=>{
    const px=side*BELT_LEN/2;
    const pg=new THREE.Group();
    // Steel shell
    const shell=new THREE.Mesh(new THREE.CylinderGeometry(0.28,0.28,BELT_W+0.08,28),steelDarkMat);
    shell.rotation.z=Math.PI/2;pg.add(shell);
    // Rubber lagging (textured grip)
    const lag=new THREE.Mesh(new THREE.CylinderGeometry(0.295,0.295,BELT_W+0.06,28,1,true),rubberMat);
    lag.rotation.z=Math.PI/2;pg.add(lag);
    // Crown ridge
    const crown=new THREE.Mesh(new THREE.CylinderGeometry(0.298,0.285,BELT_W*0.35,22),
      new THREE.MeshStandardMaterial({color:0x1a1614,roughness:0.93,metalness:0.03}));
    crown.rotation.z=Math.PI/2;pg.add(crown);
    // Hubs
    [-1,1].forEach(hs=>{
      const hub=new THREE.Mesh(new THREE.CylinderGeometry(0.17,0.17,0.06,14),rollerEndMat2);
      hub.rotation.z=Math.PI/2;hub.position.x=hs*(BELT_W/2+0.07);pg.add(hub);
      // Spokes
      for(let a=0;a<3;a++){
        const spk=new THREE.Mesh(new THREE.BoxGeometry(0.28,0.055,0.055),rollerEndMat2);
        spk.rotation.z=a*Math.PI/3;spk.rotation.x=Math.PI/2;
        spk.position.x=hs*(BELT_W/2+0.07);pg.add(spk);
      }
    });
    // Shaft
    const sh=new THREE.Mesh(new THREE.CylinderGeometry(0.035,0.035,BELT_W+0.65,8),shaftMat2);
    sh.rotation.z=Math.PI/2;pg.add(sh);
    pg.position.set(px,BELT_Y-0.085,lz);
    scene.add(pg);
    allPulleys[lineIdx].push(pg);
  });

  // Head pulley guard (safety cover at discharge end)
  const guard=new THREE.Mesh(new THREE.CylinderGeometry(0.36,0.36,BELT_W+0.3,16,1,true,0,Math.PI),
    new THREE.MeshStandardMaterial({color:0xf0cc00,roughness:0.5,metalness:0.3,side:THREE.BackSide,
      transparent:true,opacity:0.7}));
  guard.rotation.z=Math.PI/2;
  guard.position.set(BELT_LEN/2,BELT_Y-0.085,lz);
  scene.add(guard);

  // ‚îÄ‚îÄ Belt surface
  const bSurf=new THREE.Mesh(
    new THREE.BoxGeometry(BELT_LEN,0.05,BELT_W),
    new THREE.MeshStandardMaterial({map:beltTextures[lineIdx].tex,roughness:0.93,metalness:0.03})
  );
  bSurf.position.set(0,BELT_Y,lz);bSurf.receiveShadow=true;
  scene.add(bSurf);
  // Belt edge lips
  [-1,1].forEach(side=>{
    const lip=new THREE.Mesh(new THREE.BoxGeometry(BELT_LEN,0.08,0.05),rubberMat);
    lip.position.set(0,BELT_Y+0.005,lz+side*(BELT_W/2+0.025));scene.add(lip);
  });
  // Skirtboards (dust seals)
  [-1,1].forEach(side=>{
    const skirt=new THREE.Mesh(new THREE.BoxGeometry(BELT_LEN-1.5,0.22,0.022),
      new THREE.MeshStandardMaterial({color:0x3a2e24,roughness:0.9,metalness:0.2}));
    skirt.position.set(0,BELT_Y+0.12,lz+side*(BELT_W/2-0.05));
    skirt.rotation.z=side*0.05;scene.add(skirt);
  });

  // ‚îÄ‚îÄ Motor & gearbox (tail end)
  const mGrp=new THREE.Group();
  const motorBody=new THREE.Mesh(new THREE.BoxGeometry(0.65,0.5,0.5),
    new THREE.MeshStandardMaterial({color:0x3a5a3a,roughness:0.6,metalness:0.5}));
  mGrp.add(motorBody);
  for(let f=0;f<7;f++){
    const fin=new THREE.Mesh(new THREE.BoxGeometry(0.67,0.04,0.52),
      new THREE.MeshStandardMaterial({color:0x2a4a2a,roughness:0.7,metalness:0.45}));
    fin.position.y=-0.2+f*0.07;mGrp.add(fin);
  }
  const gbox=new THREE.Mesh(new THREE.BoxGeometry(0.42,0.4,0.4),
    new THREE.MeshStandardMaterial({color:0x4a4a5a,roughness:0.55,metalness:0.65}));
  gbox.position.x=0.55;mGrp.add(gbox);
  // Nameplate
  const np=new THREE.Mesh(new THREE.BoxGeometry(0.25,0.12,0.02),
    new THREE.MeshStandardMaterial({color:0xe8e0d0,roughness:0.5,metalness:0.1}));
  np.position.set(0,0.22,0.26);mGrp.add(np);
  mGrp.position.set(-BELT_LEN/2-0.55,0.75,lz);
  scene.add(mGrp);

  // Line color stripe (I-beam below belt, painted in line color)
  const stripe=new THREE.Mesh(new THREE.BoxGeometry(BELT_LEN,0.06,0.06),
    new THREE.MeshStandardMaterial({color:lcolor,emissive:new THREE.Color(lcolor),emissiveIntensity:0.15,roughness:0.5}));
  stripe.position.set(0,BELT_Y-0.2,lz+BELT_W/2+0.18);
  scene.add(stripe);
  const stripe2=stripe.clone();
  stripe2.position.z=lz-BELT_W/2-0.18;
  scene.add(stripe2);
}

buildConveyorLine(0);
buildConveyorLine(1);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// INDUSTRIAL MACHINES ‚Äî 5 per line = 10 total
// Using realistic light-grey machinery aesthetic
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const MACHINE_DATA=[
  {id:'PRS-01',name:'Hydraulic Press', w:2.8,d:2.4,h:4.5,bodyCol:0x1e3a5a,panelCol:0x1a9fff,accentCol:0x1a9fff},
  {id:'MLR-02',name:'Rolling Mill',    w:2.6,d:2.2,h:4.0,bodyCol:0x3a1a10,panelCol:0xff4d1a,accentCol:0xff4d1a},
  {id:'CNC-03',name:'CNC Lathe',       w:2.5,d:2.0,h:3.8,bodyCol:0x0e2e1e,panelCol:0x00e676,accentCol:0x00e676},
  {id:'STP-04',name:'Stamp Press',     w:3.0,d:2.4,h:5.0,bodyCol:0x2a2200,panelCol:0xffd600,accentCol:0xffd600},
  {id:'WLD-05',name:'Weld Station',    w:2.4,d:2.0,h:4.2,bodyCol:0x2a0a3a,panelCol:0xc471ed,accentCol:0xc471ed},
];
const MACHINE_XS=[-10,-5,0,5,10];
const machineLEDs=[];
const machineLights=[];
const machineLabels=[];
const machineCards=[];

// Build machine grid HTML
const mgrid=document.getElementById('machine-grid');
MACHINE_DATA.forEach((md,i)=>{
  const card=document.createElement('div');
  card.className='machine-card';
  card.innerHTML=`<div class="mc-status"><div class="mc-dot"></div><span class="mc-id">${md.id}</span></div><div class="mc-name">${md.name}</div><div class="mc-faults" style="color:var(--green)">0 faults</div>`;
  mgrid.appendChild(card);
  machineCards.push(card);
});

// For each machine, build for BOTH lines
const lineOffset=[LINE_Z[0],LINE_Z[1]];
MACHINE_DATA.forEach((md,mi)=>{
  lineOffset.forEach((lz,li)=>{
    const x=MACHINE_XS[mi];
    const g=new THREE.Group();
    const bMat=new THREE.MeshStandardMaterial({color:md.bodyCol,roughness:0.55,metalness:0.35});

    // Plinth
    const plinth=new THREE.Mesh(new THREE.BoxGeometry(md.w+0.4,0.28,md.d+0.3),
      new THREE.MeshStandardMaterial({color:0xb8b4ac,roughness:0.8,metalness:0.3}));
    plinth.position.set(x,0.14,lz-md.d/2-1.0);
    plinth.castShadow=true;plinth.receiveShadow=true;g.add(plinth);

    // Body
    const body=new THREE.Mesh(new THREE.BoxGeometry(md.w,md.h,md.d),bMat);
    body.position.set(x,BELT_Y+md.h/2+0.1,lz-md.d/2-1.0);
    body.castShadow=true;body.receiveShadow=true;g.add(body);

    // Sheet metal panel seams
    const seamMat=new THREE.MeshStandardMaterial({color:0xa8a4a0,roughness:0.7,metalness:0.4});
    [1.2,2.5,3.5].forEach(sy=>{
      const seam=new THREE.Mesh(new THREE.BoxGeometry(md.w+0.01,0.04,md.d+0.01),seamMat);
      seam.position.set(x,BELT_Y+sy,lz-md.d/2-1.0);g.add(seam);
    });
    // Vertical seam
    const vs=new THREE.Mesh(new THREE.BoxGeometry(0.04,md.h,md.d+0.01),seamMat);
    vs.position.set(x+0.8,BELT_Y+md.h/2+0.1,lz-md.d/2-1.0);g.add(vs);

    // Operator panel (recessed into front face)
    const front=lz>0 ? lz-md.d/2-1.0+md.d/2 : lz-md.d/2-1.0+md.d/2;
    const faceZ=lz+(lz>0?-1.0-md.d/2+md.d/2+0.01:-1.0-md.d/2+md.d/2+0.01);
    // Actually: front face of machine
    const faceOffset = lz > 0 ? lz - 1.0 + 0.01 : lz - 1.0 + 0.01;

    // Panel box (inset)
    const opPanel=new THREE.Mesh(new THREE.BoxGeometry(md.w*0.55,1.2,0.05),
      new THREE.MeshStandardMaterial({color:0x22304a,roughness:0.7,metalness:0.3}));
    opPanel.position.set(x-0.2,BELT_Y+2.0,faceOffset);g.add(opPanel);

    // HMI screen (light grey bezel, glowing screen)
    const screenBez=new THREE.Mesh(new THREE.BoxGeometry(0.7,0.5,0.04),
      new THREE.MeshStandardMaterial({color:0x1a2030,roughness:0.6,metalness:0.3}));
    screenBez.position.set(x-0.2,BELT_Y+2.2,faceOffset+0.01);g.add(screenBez);
    const scrCol = new THREE.Color(md.panelCol);
    const screen=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.38,0.03),
      new THREE.MeshStandardMaterial({color:scrCol,emissive:scrCol,emissiveIntensity:0.55,roughness:0.25}));
    screen.position.set(x-0.2,BELT_Y+2.2,faceOffset+0.03);g.add(screen);

    // Physical controls row
    const btnCols=[0xee3311,0xffaa00,0x22cc44];
    btnCols.forEach((bc,bi)=>{
      const btn=new THREE.Mesh(new THREE.CylinderGeometry(0.045,0.045,0.04,10),
        new THREE.MeshStandardMaterial({color:bc,emissive:new THREE.Color(bc),emissiveIntensity:0.4,roughness:0.3}));
      btn.rotation.x=Math.PI/2;
      btn.position.set(x+0.2+bi*0.1,BELT_Y+1.65,faceOffset+0.01);g.add(btn);
    });
    // E-stop
    const estop=new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.06,0.06,12),
      new THREE.MeshStandardMaterial({color:0xff0000,emissive:0x770000,emissiveIntensity:0.35,roughness:0.3}));
    estop.rotation.x=Math.PI/2;estop.position.set(x+0.55,BELT_Y+1.75,faceOffset+0.01);g.add(estop);

    // Accent color header stripe
    const hStripe=new THREE.Mesh(new THREE.BoxGeometry(md.w+0.01,0.12,md.d+0.01),
      new THREE.MeshStandardMaterial({color:md.accentCol,roughness:0.4,metalness:0.5}));
    hStripe.position.set(x,BELT_Y+md.h-0.06,lz-md.d/2-1.0);g.add(hStripe);

    // Safety beacon (yellow/amber rotating on top)
    const bBase=new THREE.Mesh(new THREE.CylinderGeometry(0.09,0.1,0.1,10),
      new THREE.MeshStandardMaterial({color:0x909090,roughness:0.5,metalness:0.8}));
    bBase.position.set(x-0.6,BELT_Y+md.h+0.35,lz-md.d/2-1.0);g.add(bBase);
    const bDome=new THREE.Mesh(new THREE.SphereGeometry(0.12,10,7,0,Math.PI*2,0,Math.PI*0.55),
      new THREE.MeshStandardMaterial({color:0xffcc00,emissive:0xffaa00,emissiveIntensity:1.2,roughness:0.15,transparent:true,opacity:0.88}));
    bDome.position.set(x-0.6,BELT_Y+md.h+0.45,lz-md.d/2-1.0);g.add(bDome);
    machineLEDs.push(bDome);

    // Pneumatic pipes on side
    const pipeMat=new THREE.MeshStandardMaterial({color:0x888890,roughness:0.5,metalness:0.8});
    [0.4,0.65].forEach(pOff=>{
      const pipe=new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,2.8,8),pipeMat);
      pipe.rotation.z=Math.PI/2;pipe.position.set(x,BELT_Y+pOff+1.2,lz-1.0-md.d/2+pOff*0.3);g.add(pipe);
    });

    // Coolant lines (blue/green braided hose)
    const hoseMat=new THREE.MeshStandardMaterial({color:0x3a6a8a,roughness:0.6,metalness:0.4});
    const hose=new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.025,1.8,7),hoseMat);
    hose.rotation.z=Math.PI/2;hose.position.set(x,BELT_Y+0.8,lz-1.0-md.d/2+0.6);g.add(hose);

    // Exhaust stack / duct on top
    const duct=new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.12,1.0,10),
      new THREE.MeshStandardMaterial({color:0x888888,roughness:0.7,metalness:0.75}));
    duct.position.set(x+0.55,BELT_Y+md.h+0.75,lz-md.d/2-1.0);g.add(duct);
    // Duct elbow cap
    const dCap=new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.11,0.1,10),
      new THREE.MeshStandardMaterial({color:0x707070,roughness:0.65,metalness:0.8}));
    dCap.position.set(x+0.55,BELT_Y+md.h+1.3,lz-md.d/2-1.0);g.add(dCap);

    // Machine light (warm work area light)
    const mpl=new THREE.PointLight(md.accentCol,0.4,8);
    mpl.position.set(x,BELT_Y+2.5,lz-md.d/2-1.0);g.add(mpl);
    machineLights.push(mpl);

    scene.add(g);
  });
});

// Machine label canvases (one per machine, above the belt)
MACHINE_DATA.forEach((md,mi)=>{
  const lc=document.createElement('canvas');lc.width=256;lc.height=96;
  const lt=lc.getContext('2d');
  const tex=new THREE.CanvasTexture(lc);
  function updateLabel(defects){
    lt.clearRect(0,0,256,96);
    // bg
    lt.fillStyle='rgba(10,20,35,0.92)';
    lt.roundRect(4,4,248,88,6);lt.fill();
    lt.strokeStyle='rgba(26,159,255,0.5)';lt.lineWidth=2;
    lt.roundRect(4,4,248,88,6);lt.stroke();
    // id
    lt.fillStyle='#1a9fff';lt.font='bold 20px Barlow Condensed,sans-serif';lt.textAlign='center';
    lt.fillText(md.id,128,30);
    // name
    lt.fillStyle='#6090c0';lt.font='12px Barlow,sans-serif';
    lt.fillText(md.name,128,50);
    // faults
    lt.fillStyle=defects>0?'#ff4d1a':'#00e676';
    lt.font='bold 14px JetBrains Mono,monospace';
    lt.fillText(`${defects} fault${defects!==1?'s':''}`,128,72);
    tex.needsUpdate=true;
  }
  const lmat=new THREE.MeshBasicMaterial({map:tex,transparent:true,depthWrite:false,side:THREE.DoubleSide});
  const lmesh=new THREE.Mesh(new THREE.PlaneGeometry(2.0,0.75),lmat);
  lmesh.position.set(MACHINE_XS[mi],BELT_Y+0.7,0);
  lmesh.rotation.x=-Math.PI*0.15;
  scene.add(lmesh);
  machineLabels.push({updateLabel,defects:0,card:machineCards[mi]});
  updateLabel(0);
});

// Shape stage indicator labels ‚Äî between machines, above belt
const STAGE_NAMES=['Flat Sheet','U-Channel','Rolled Profile','Disc Part','Stamped Plate','Welded Assembly'];
const STAGE_ARROWS=['‚Üí','‚Üí','‚Üí','‚Üí','‚Üí'];
[-10,-5,0,5,10].forEach((mx,mi)=>{
  const sc=document.createElement('canvas');sc.width=220;sc.height=64;
  const st=sc.getContext('2d');
  st.fillStyle='rgba(8,18,32,0.88)';st.roundRect(3,3,214,58,5);st.fill();
  st.strokeStyle='rgba(0,230,118,0.5)';st.lineWidth=1.5;st.roundRect(3,3,214,58,5);st.stroke();
  st.fillStyle='#00e676';st.font='bold 11px Barlow Condensed,sans-serif';st.textAlign='center';
  st.fillText(`Stage ${mi}‚Üí${mi+1}`,110,20);
  st.fillStyle='#b0cce8';st.font='10px Barlow,sans-serif';
  st.fillText(STAGE_NAMES[mi],110,36);
  st.fillStyle='#4a7090';st.font='9px JetBrains Mono,monospace';
  st.fillText(`‚Üí ${STAGE_NAMES[mi+1]}`,110,52);
  const tex=new THREE.CanvasTexture(sc);
  const m=new THREE.Mesh(new THREE.PlaneGeometry(1.7,0.5),
    new THREE.MeshBasicMaterial({map:tex,transparent:true,depthWrite:false,side:THREE.DoubleSide}));
  m.position.set(mx,BELT_Y+3.2,0);scene.add(m);
});


// Industrial X-ray / vision system style
// Bright white/grey clean look
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DETECTOR_XS=[];
for(let i=0;i<4;i++) DETECTOR_XS.push((MACHINE_XS[i]+MACHINE_XS[i+1])/2);

const detectorSets=[]; // per line per detector gap
const gantryMat=new THREE.MeshStandardMaterial({color:0x1e3050,roughness:0.4,metalness:0.82});
const gantryAccMat=new THREE.MeshStandardMaterial({color:0x1a9fff,roughness:0.35,metalness:0.7});

LINE_Z.forEach((lz,li)=>{
  DETECTOR_XS.forEach((dx,di)=>{
    const g=new THREE.Group();

    // Side uprights
    [-1,1].forEach(side=>{
      const upZ=lz+side*(BELT_W/2+0.75);
      const up=new THREE.Mesh(new THREE.BoxGeometry(0.18,7.5,0.18),gantryMat);
      up.position.set(dx,3.75,upZ);up.castShadow=true;g.add(up);
      // Foot plate
      const fp=new THREE.Mesh(new THREE.BoxGeometry(0.32,0.07,0.32),gantryMat);
      fp.position.set(dx,0.035,upZ);g.add(fp);
      // Top cap
      const tc=new THREE.Mesh(new THREE.BoxGeometry(0.24,0.1,0.24),gantryMat);
      tc.position.set(dx,7.55,upZ);g.add(tc);
    });

    // Overhead bridge beam
    const bridge=new THREE.Mesh(new THREE.BoxGeometry(0.22,0.25,BELT_W+1.65),gantryMat);
    bridge.position.set(dx,7.3,lz);g.add(bridge);

    // Scanner head (hanging from bridge)
    const headMat=new THREE.MeshStandardMaterial({color:0x162840,roughness:0.38,metalness:0.82});
    const head=new THREE.Mesh(new THREE.BoxGeometry(0.55,0.72,BELT_W+0.14),headMat);
    head.position.set(dx,6.5,lz);head.castShadow=true;g.add(head);

    // Safety yellow stripe on head
    const yStripe=new THREE.Mesh(new THREE.BoxGeometry(0.57,0.08,BELT_W+0.16),
      new THREE.MeshStandardMaterial({color:0xffcc00,roughness:0.5,metalness:0.3}));
    yStripe.position.set(dx,6.1,lz);g.add(yStripe);

    // Aperture window
    const apt=new THREE.Mesh(new THREE.BoxGeometry(0.07,0.52,BELT_W+0.08),
      new THREE.MeshStandardMaterial({color:0x0a1a2a,emissive:0x0055aa,emissiveIntensity:0.6,roughness:0.15}));
    apt.position.set(dx+0.29,6.5,lz);g.add(apt);

    // Receiver (opposite)
    const rcv=new THREE.Mesh(new THREE.BoxGeometry(0.22,0.38,BELT_W+0.1),
      new THREE.MeshStandardMaterial({color:0xd0ccc4,emissive:0x002244,emissiveIntensity:0.3,roughness:0.3}));
    rcv.position.set(dx-0.3,6.5,lz);g.add(rcv);

    // LED status strip
    const statusLeds=[];
    const sColors=[0x22cc44,0xffaa00,0xee2211];
    sColors.forEach((sc,si)=>{
      const sled=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.04,0.04),
        new THREE.MeshStandardMaterial({color:sc,emissive:new THREE.Color(sc),emissiveIntensity:si===0?1.8:0.2,roughness:0.2}));
      sled.position.set(dx+0.29,6.85-si*0.1,lz+BELT_W/2+0.08);
      g.add(sled);statusLeds.push(sled);
    });

    // Cable trunking
    const trunk=new THREE.Mesh(new THREE.BoxGeometry(0.09,0.09,0.09),gantryMat);
    trunk.position.set(dx+0.15,7.05,lz+BELT_W/2+0.5);g.add(trunk);
    const cable=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.7,5),
      new THREE.MeshStandardMaterial({color:0x303030,roughness:0.9}));
    cable.position.set(dx+0.15,7.4,lz+BELT_W/2+0.5);g.add(cable);

    // Warning label plate
    const wlp=new THREE.Mesh(new THREE.BoxGeometry(0.22,0.22,0.015),
      new THREE.MeshStandardMaterial({color:0xffee00,emissive:0x443300,emissiveIntensity:0.3,roughness:0.5}));
    wlp.position.set(dx+0.29,6.5,lz+BELT_W/2+0.08);
    wlp.rotation.y=Math.PI/2;g.add(wlp);

    // Scanner ID label
    const slc=document.createElement('canvas');slc.width=120;slc.height=48;
    const slt=slc.getContext('2d');
    slt.fillStyle='rgba(10,22,38,0.92)';slt.fillRect(2,2,116,44);
    slt.strokeStyle='rgba(26,159,255,0.5)';slt.lineWidth=1.5;slt.strokeRect(2,2,116,44);
    slt.fillStyle='#1a9fff';slt.font='bold 14px Barlow Condensed,sans-serif';slt.textAlign='center';
    slt.fillText(`S-${di+1}`,60,22);
    slt.fillStyle='#4a7090';slt.font='10px JetBrains Mono,monospace';
    slt.fillText(`LINE ${li+1}`,60,38);
    const stex=new THREE.CanvasTexture(slc);
    const slm=new THREE.Mesh(new THREE.PlaneGeometry(0.7,0.28),
      new THREE.MeshBasicMaterial({map:stex,transparent:true,depthWrite:false}));
    slm.position.set(dx,7.7,lz);g.add(slm);

    // Scan beam (flat curtain of light ‚Äî realistic X-ray/laser curtain)
    const beamMat=new THREE.MeshBasicMaterial({
      color:0x44aaff,transparent:true,opacity:0,depthWrite:false,side:THREE.DoubleSide
    });
    const beamGeo=new THREE.PlaneGeometry(0.06,2.2);
    // Multiple beam planes at different Z to simulate volumetric
    const beamPlanes=[];
    for(let bp=0;bp<5;bp++){
      const bm=new THREE.Mesh(beamGeo,beamMat.clone());
      bm.position.set(dx,BELT_Y+1.1,lz+(bp-2)*0.25);
      bm.rotation.y=Math.PI/2;
      g.add(bm);beamPlanes.push(bm);
    }

    const beamLight=new THREE.PointLight(0x44aaff,0,5);
    beamLight.position.set(dx,BELT_Y+0.5,lz);g.add(beamLight);

    scene.add(g);
    detectorSets.push({g,dx,lz,li,di,statusLeds,beamPlanes,beamLight,
      scanning:false,scanProgress:0,busy:false,
      flash:0,result:null,beamAlpha:0});
  });
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SAFETY RAILINGS (bright yellow)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const yrail=new THREE.MeshStandardMaterial({color:0xffcc00,roughness:0.5,metalness:0.65});
const ypost=new THREE.MeshStandardMaterial({color:0xddbb00,roughness:0.55,metalness:0.7});
[-5.5,-6.0,5.5,6.0].forEach(rz=>{
  const tr=new THREE.Mesh(new THREE.CylinderGeometry(0.028,0.028,28,8),yrail);
  tr.rotation.z=Math.PI/2;tr.position.set(0,1.1,rz);scene.add(tr);
  const mr=new THREE.Mesh(new THREE.CylinderGeometry(0.022,0.022,28,8),yrail);
  mr.rotation.z=Math.PI/2;mr.position.set(0,0.55,rz);scene.add(mr);
  for(let px=-13;px<=13;px+=2){
    const p=new THREE.Mesh(new THREE.BoxGeometry(0.05,1.15,0.05),ypost);
    p.position.set(px,0.575,rz);scene.add(p);
    const pb=new THREE.Mesh(new THREE.BoxGeometry(0.16,0.055,0.16),ypost);
    pb.position.set(px,0.027,rz);scene.add(pb);
  }
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// WORKPIECES (metal sheets/parts)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DEFECTS=[
  {name:'Surface Crack',   desc:'Fracture on top face',        hex:'#c8401a'},
  {name:'Porosity',        desc:'Internal gas pockets',        hex:'#d46a1a'},
  {name:'Warping',         desc:'Dimensional deviation',       hex:'#c8a020'},
  {name:'Corrosion',       desc:'Oxidation layer detected',    hex:'#8a4ac8'},
  {name:'Edge Inclusion',  desc:'Foreign material in edge',    hex:'#2a6fad'},
  {name:'Delamination',    desc:'Layer separation detected',   hex:'#c83070'},
];

let sheetsByLine=[[],[]];
let sheetIdCounter=0,spawnTimers=[0,0];
const machineDefects=[0,0,0,0,0];

// Realistic machined part materials (aluminum/steel plate look)
function makePartMat(){
  const lightness=0.72+Math.random()*0.12;
  const c=new THREE.Color().setHSL(0.59+Math.random()*0.05,0.08,lightness);
  return new THREE.MeshStandardMaterial({
    color:c,roughness:0.2+Math.random()*0.12,metalness:0.88,envMapIntensity:1.2
  });
}

// Shape stages: flat sheet ‚Üí pressed ‚Üí rolled ‚Üí lathed ‚Üí stamped ‚Üí welded assembly
// Each stage defines how to rebuild the mesh group
const SHAPE_STAGES=[
  // Stage 0: Raw flat sheet (start)
  (grp,mat)=>{
    const m=new THREE.Mesh(new THREE.BoxGeometry(1.6,0.07,1.3),mat);
    m.castShadow=true;grp.add(m);
    // edge highlight
    const eh=new THREE.Mesh(new THREE.BoxGeometry(1.55,0.008,1.25),
      new THREE.MeshStandardMaterial({color:0xdde8f0,roughness:0.1,metalness:0.98}));
    eh.position.y=0.036;grp.add(eh);
  },
  // Stage 1: After Hydraulic Press ‚Äî curved/bowed shape (U-channel)
  (grp,mat)=>{
    // Main body flattened sides
    const base=new THREE.Mesh(new THREE.BoxGeometry(1.5,0.07,1.2),mat);
    grp.add(base);
    // Raised flanges on sides (pressed up)
    [-1,1].forEach(s=>{
      const flange=new THREE.Mesh(new THREE.BoxGeometry(1.5,0.28,0.09),mat);
      flange.position.set(0,0.14,s*0.56);grp.add(flange);
    });
  },
  // Stage 2: After Rolling Mill ‚Äî elongated thinner rolled profile
  (grp,mat)=>{
    const rolled=new THREE.Mesh(new THREE.BoxGeometry(1.9,0.05,1.1),mat);
    grp.add(rolled);
    // Rolling lines (surface texture marks)
    for(let i=-0.7;i<=0.7;i+=0.35){
      const line=new THREE.Mesh(new THREE.BoxGeometry(1.92,0.005,0.04),
        new THREE.MeshStandardMaterial({color:0xb0bcc8,roughness:0.15,metalness:0.99}));
      line.position.set(0,0.028,i);grp.add(line);
    }
  },
  // Stage 3: After CNC Lathe ‚Äî circular disc with hole
  (grp,mat)=>{
    const disc=new THREE.Mesh(new THREE.CylinderGeometry(0.72,0.72,0.09,28),mat);
    disc.rotation.x=0;grp.add(disc);
    // Center bore hole (dark cap)
    const hole=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.1,16),
      new THREE.MeshStandardMaterial({color:0x050a10,roughness:0.9,metalness:0.2}));
    grp.add(hole);
    // Machined ring
    const ring=new THREE.Mesh(new THREE.CylinderGeometry(0.74,0.74,0.02,28,1,true),
      new THREE.MeshStandardMaterial({color:0xd0dce8,roughness:0.08,metalness:0.99}));
    ring.position.y=0.045;grp.add(ring);
  },
  // Stage 4: After Stamp Press ‚Äî stamped plate with embossed pattern
  (grp,mat)=>{
    const plate=new THREE.Mesh(new THREE.BoxGeometry(1.4,0.08,1.1),mat);
    grp.add(plate);
    // Embossed ribs
    for(let i=-0.3;i<=0.3;i+=0.3){
      const rib=new THREE.Mesh(new THREE.BoxGeometry(1.38,0.04,0.12),mat);
      rib.position.set(0,0.06,i);grp.add(rib);
    }
    // Punched holes
    [[-0.4,-0.3],[0.4,-0.3],[-0.4,0.3],[0.4,0.3]].forEach(([hx,hz])=>{
      const hole=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,0.1,10),
        new THREE.MeshStandardMaterial({color:0x050a10,roughness:0.9}));
      hole.rotation.x=Math.PI/2;hole.position.set(hx,0.02,hz);grp.add(hole);
    });
  },
  // Stage 5: After Weld Station ‚Äî assembled bracket with welds
  (grp,mat)=>{
    // Base plate
    const base=new THREE.Mesh(new THREE.BoxGeometry(1.3,0.07,0.9),mat);
    grp.add(base);
    // Upright bracket
    const bracket=new THREE.Mesh(new THREE.BoxGeometry(0.08,0.5,0.88),mat);
    bracket.position.set(0,0.28,0);grp.add(bracket);
    // Top flange
    const topFlange=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.07,0.88),mat);
    topFlange.position.set(0,0.54,0);grp.add(topFlange);
    // Weld beads (yellow-orange)
    const weldMat=new THREE.MeshStandardMaterial({color:0xff8800,emissive:0x441100,emissiveIntensity:0.5,roughness:0.8,metalness:0.2});
    [-0.04,0.04].forEach(wz=>{
      const weld=new THREE.Mesh(new THREE.BoxGeometry(0.06,0.06,0.88),weldMat);
      weld.position.set(wz,0.055,0);grp.add(weld);
    });
  }
];

function rebuildShapeMesh(s, stage){
  // Remove old mesh from scene and group
  scene.remove(s.mesh);
  const grp=new THREE.Group();
  SHAPE_STAGES[stage](grp,s.mat);
  grp.castShadow=true;
  scene.add(grp);
  s.mesh=grp;
  s.currentStage=stage;
  // Flash transform effect
  s.transformFlash=0.5;
}

function spawnSheet(lineIdx){
  const lz=LINE_Z[lineIdx];
  const mat=makePartMat();
  const grp=new THREE.Group();
  SHAPE_STAGES[0](grp,mat);
  grp.castShadow=true;
  scene.add(grp);
  const s={
    id:sheetIdCounter++,mesh:grp,mat,lineIdx,
    x:-BELT_LEN/2-2.2,
    sourceMachine:0,lastMachinePassed:-1,
    currentStage:0,
    transformFlash:0,
    defective:false,defectType:null,
    scannedBy:Array(4).fill(false),
    glowTimer:0,done:false,defectMesh:null,
    w:1.6,d:1.3,
    // Robot arm pickup state
    beingPickedUp:false,pickupProgress:0,pickupArm:null
  };
  sheetsByLine[lineIdx].push(s);
}

// Particles
const particlePool=[];
function spawnParticles(pos,color){
  for(let i=0;i<12;i++){
    const geo=new THREE.SphereGeometry(0.025+Math.random()*0.04,5,5);
    const mat=new THREE.MeshBasicMaterial({color,transparent:true,opacity:1});
    const mesh=new THREE.Mesh(geo,mat);mesh.position.copy(pos);scene.add(mesh);
    const sp=0.025+Math.random()*0.06;
    const th=Math.random()*Math.PI*2,ph=Math.random()*Math.PI;
    particlePool.push({mesh,mat,
      vx:Math.sin(ph)*Math.cos(th)*sp,
      vy:Math.abs(Math.cos(ph)*sp)+0.025,
      vz:Math.sin(ph)*Math.sin(th)*sp,life:1});
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ROBOT ARMS ‚Äî one per line, at end of belt (x=14)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ROBOT_X = 12.5; // positioned after last detector
const REJECT_BIN_X = ROBOT_X + 0.5;
const robotArms = [];

function buildRobotArm(lineIdx){
  const lz = LINE_Z[lineIdx];
  const armColor = 0x1e3a5a;
  const jointColor = 0xffd600;
  const g = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({color:armColor,roughness:0.4,metalness:0.75});
  const jmat = new THREE.MeshStandardMaterial({color:jointColor,roughness:0.3,metalness:0.8,emissive:0x332200,emissiveIntensity:0.2});

  // Base pedestal
  const ped = new THREE.Mesh(new THREE.CylinderGeometry(0.22,0.28,0.5,12), mat);
  ped.position.set(ROBOT_X, 0.25, lz + (lineIdx===0?2.2:-2.2));
  g.add(ped);

  // Shoulder joint
  const shoulder = new THREE.Mesh(new THREE.SphereGeometry(0.16,12,8), jmat);
  shoulder.position.set(ROBOT_X, 0.68, lz + (lineIdx===0?2.2:-2.2));
  g.add(shoulder);

  // Upper arm ‚Äî will rotate
  const upperArm = new THREE.Group();
  upperArm.position.set(ROBOT_X, 0.68, lz + (lineIdx===0?2.2:-2.2));
  const uArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.6,0.1), mat);
  uArmMesh.position.y = 0.3; g.add(upperArm); upperArm.add(uArmMesh);

  // Elbow joint
  const elbow = new THREE.Mesh(new THREE.SphereGeometry(0.13,10,7), jmat);
  elbow.position.y = 0.6; upperArm.add(elbow);

  // Forearm ‚Äî will rotate
  const foreArm = new THREE.Group();
  foreArm.position.y = 0.6; upperArm.add(foreArm);
  const fArmMesh = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.5,0.08), mat);
  fArmMesh.position.y = 0.25; foreArm.add(fArmMesh);

  // Wrist + gripper
  const wrist = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.07,0.06,10), jmat);
  wrist.position.y = 0.5; foreArm.add(wrist);

  // Gripper fingers
  const gripperGrp = new THREE.Group();
  gripperGrp.position.y = 0.54; foreArm.add(gripperGrp);
  [-1,1].forEach(s=>{
    const finger = new THREE.Mesh(new THREE.BoxGeometry(0.04,0.12,0.04),mat);
    finger.position.set(s*0.09, -0.06, 0); gripperGrp.add(finger);
  });

  // Reject bin next to arm
  const binMat = new THREE.MeshStandardMaterial({color:0x8a1a0a,roughness:0.6,metalness:0.4});
  const binBase = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.5,0.8), binMat);
  binBase.position.set(REJECT_BIN_X+(lineIdx===0?1.2:-1.2), 0.25, lz+(lineIdx===0?2.8:-2.8));
  g.add(binBase);
  // Bin stripes
  const stripeMat = new THREE.MeshStandardMaterial({color:0xffcc00,roughness:0.5});
  [0.15,0.25,0.35].forEach(sy=>{
    const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.82,0.04,0.82),stripeMat);
    stripe.position.set(REJECT_BIN_X+(lineIdx===0?1.2:-1.2), sy, lz+(lineIdx===0?2.8:-2.8));
    g.add(stripe);
  });
  // Bin label
  const binLabel = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.12,0.01),
    new THREE.MeshStandardMaterial({color:0xff2200,emissive:0x440000,emissiveIntensity:0.4}));
  binLabel.position.set(REJECT_BIN_X+(lineIdx===0?1.2:-1.2), 0.38, lz+(lineIdx===0?2.8:-2.8)+0.41);
  g.add(binLabel);

  scene.add(g);

  robotArms.push({
    grp: g,
    upperArm, foreArm, gripperGrp,
    baseX: ROBOT_X,
    baseZ: lz + (lineIdx===0?2.2:-2.2),
    binX: REJECT_BIN_X+(lineIdx===0?1.2:-1.2),
    binZ: lz+(lineIdx===0?2.8:-2.8),
    lineIdx,
    state: 'idle', // idle | reaching | gripping | lifting | depositing | returning
    progress: 0,
    targetSheet: null,
    // Store original/default pose angles
    restRotX: 0.1, restRotZ: (lineIdx===0?-0.3:0.3),
    currentSheetY: BELT_Y + 0.15,
    gripping: false
  });
}

buildRobotArm(0);
buildRobotArm(1);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SIM STATE
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let simRunning=true,forceFault=false,forceFaultLine=-1;
let totScan=0,totDef=0,totPass=0,defectCount=0;
let frame=0;
const clock3=new THREE.Clock();
function getSpeed(){return parseInt(document.getElementById('spd').value);}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// UPDATE
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function update(dt){
  if(!simRunning)return;
  frame++;
  const spd=getSpeed();

  // Belt texture animation
  [0,1].forEach(li=>{
    beltOffsets[li]=(beltOffsets[li]+spd*1.4)%80;
    if(frame%(li===0?1:2)===0)
      beltTextures[li].redraw(beltOffsets[li]*12.8);
  });

  // Roller/pulley rotation
  const omega=spd*1.4;
  allRollers.forEach(rl=>rl.forEach(r=>r.rotation.x+=omega*dt));
  allPulleys.forEach(pl=>pl.forEach(p=>p.rotation.x+=omega*dt*0.85));

  // Ceiling light flicker (very subtle)
  ceilLights.forEach((cl,i)=>{
    cl.intensity=0.85+Math.sin(Date.now()*0.002+i*0.7)*0.06;
  });

  // Spawn workpieces
  [0,1].forEach(li=>{
    spawnTimers[li]-=dt;
    const interval=Math.max(0.55,2.4-spd*0.28);
    if(spawnTimers[li]<=0&&sheetsByLine[li].length<10){
      spawnSheet(li);spawnTimers[li]=interval+(Math.random()-0.5)*0.3;
    }
  });

  // Move workpieces
  const dx=spd*dt*2.5;
  [0,1].forEach(li=>{
    const lz=LINE_Z[li];
    sheetsByLine[li].forEach(s=>{
      // Only move if not being picked up by robot arm
      if(!s.beingPickedUp){
        s.x+=dx;
        s.mesh.position.set(s.x,BELT_Y+0.065,lz);
      }

      // Transform flash effect
      if(s.transformFlash>0){
        s.transformFlash-=dt*2;
        const fi=Math.max(0,s.transformFlash);
        s.mat.emissive.setHex(0x2266ff);
        s.mat.emissiveIntensity=fi*0.5;
      }

      // Robot arm pickup trigger for defective sheets near end
      if(s.defective && !s.beingPickedUp && !s.pickedUp){
        const arm = robotArms[li];
        if(s.x > ROBOT_X - 2.5 && s.x < ROBOT_X + 0.5 && arm.state==='idle'){
          arm.state='reaching';arm.progress=0;arm.targetSheet=s;
          s.beingPickedUp=true;
        }
      }

      // Machine tracking + shape morphing
      MACHINE_XS.forEach((mx,mi)=>{
        if(s.x>mx-0.7&&mi>s.lastMachinePassed){
          s.lastMachinePassed=mi;s.sourceMachine=mi;
          machineLights[mi*2+li].intensity=1.1;
          setTimeout(()=>machineLights[mi*2+li].intensity=0.4,350);
          // Transform shape to match machine stage
          const newStage = mi + 1;
          if(newStage < SHAPE_STAGES.length){
            rebuildShapeMesh(s, newStage);
          }
        }
      });

      // Detector proximity
      detectorSets.forEach((det,di_)=>{
        if(det.li!==li)return;
        if(Math.abs(s.x-det.dx)<(dx+0.14)&&!s.scannedBy[det.di]){
          s.scannedBy[det.di]=true;
          triggerDetector(det,s);
        }
      });

      // Defect glow
      if(s.glowTimer>0){
        s.glowTimer-=dt;
        s.mat.emissive.setHex(0x8a1a0a);
        s.mat.emissiveIntensity=Math.min(1,s.glowTimer)*0.35;
      }else{s.mat.emissiveIntensity=0;}

      if(s.x>BELT_LEN/2+2.5){
        scene.remove(s.mesh);
        if(s.defectMesh)scene.remove(s.defectMesh);
        s.done=true;
      }
    });
    sheetsByLine[li]=sheetsByLine[li].filter(s=>!s.done);
  });

  // Detector updates
  detectorSets.forEach(det=>{
    if(det.scanning){
      det.scanProgress+=dt*1.1;
      det.beamAlpha=Math.min(1,det.beamAlpha+dt*5);
      const pulse=0.35+Math.sin(det.scanProgress*14)*0.22;
      det.beamPlanes.forEach((bp,bpi)=>{
        const phaseOff=Math.sin(det.scanProgress*10+bpi*0.6)*0.12;
        bp.material.opacity=det.beamAlpha*(pulse+phaseOff);
      });
      det.beamLight.intensity=det.beamAlpha*1.8;
      if(det.scanProgress>=1){
        det.scanning=false;
        det.beamAlpha=0;
        det.beamPlanes.forEach(bp=>bp.material.opacity=0);
        det.beamLight.intensity=0;
        if(det.result){
          const{sheet,isDefect,defectType}=det.result;
          if(isDefect){
            sheet.defective=true;sheet.defectType=defectType;
            sheet.glowTimer=2.8;sheet.mat.color.setHex(0x8a3a28);
            det.flash=1.8;
            det.statusLeds[2].material.emissiveIntensity=2.2;
            det.statusLeds[1].material.emissiveIntensity=0.15;
            det.statusLeds[0].material.emissiveIntensity=0.15;
            det.beamPlanes.forEach(bp=>bp.material.color.setHex(0xff2200));
            det.beamLight.color.setHex(0xff3300);
            addDefectMarker(sheet);
            machineDefects[sheet.sourceMachine]++;
            machineLabels[sheet.sourceMachine].defects++;
            machineLabels[sheet.sourceMachine].updateLabel(machineLabels[sheet.sourceMachine].defects);
            // Update card
            const card=machineCards[sheet.sourceMachine];
            card.querySelector('.mc-faults').style.color='var(--accent)';
            card.querySelector('.mc-faults').textContent=`${machineLabels[sheet.sourceMachine].defects} faults`;
            card.classList.add('has-fault');
            spawnParticles(new THREE.Vector3(det.dx,BELT_Y+0.5,det.lz),0xff3322);
            totDef++;totScan++;
            logDefect(sheet,det);
          }else{
            det.flash=0.7;
            det.statusLeds[0].material.emissiveIntensity=2.2;
            det.statusLeds[1].material.emissiveIntensity=0.15;
            det.statusLeds[2].material.emissiveIntensity=0.15;
            det.beamPlanes.forEach(bp=>bp.material.color.setHex(0x22ff88));
            det.beamLight.color.setHex(0x22ff66);
            spawnParticles(new THREE.Vector3(det.dx,BELT_Y+0.5,det.lz),0x44cc88);
            totPass++;totScan++;
          }
          det.result=null;det.busy=false;updateHUD();
        }
      }
    }
    if(det.flash>0){
      det.flash-=dt*1.1;
      if(det.flash<=0){
        det.flash=0;
        det.statusLeds[0].material.emissiveIntensity=1.8;
        det.statusLeds[1].material.emissiveIntensity=0.15;
        det.statusLeds[2].material.emissiveIntensity=0.15;
        det.beamPlanes.forEach(bp=>bp.material.color.setHex(0x44aaff));
        det.beamLight.color.setHex(0x44aaff);
      }
    }
    if(!det.scanning&&det.flash<=0){
      const t=Date.now()*0.002+det.di*0.5;
      det.statusLeds[0].material.emissiveIntensity=1.6+Math.sin(t)*0.5;
    }
  });

  // Particles
  for(let i=particlePool.length-1;i>=0;i--){
    const p=particlePool[i];
    p.mesh.position.x+=p.vx;p.mesh.position.y+=p.vy;p.mesh.position.z+=p.vz;
    p.vy-=0.0025;p.life-=dt*1.3;
    p.mat.opacity=Math.max(0,p.life);
    if(p.life<=0){scene.remove(p.mesh);particlePool.splice(i,1);}
  }

  // ‚îÄ‚îÄ‚îÄ Robot Arm Updates ‚îÄ‚îÄ‚îÄ
  robotArms.forEach(arm=>{
    if(arm.state==='idle'){
      // Gentle idle sway
      const t=Date.now()*0.0008;
      arm.upperArm.rotation.x = arm.restRotX + Math.sin(t)*0.05;
      arm.upperArm.rotation.z = arm.restRotZ + Math.cos(t*0.7)*0.03;
      arm.foreArm.rotation.x = -0.3 + Math.sin(t*0.9)*0.04;
      return;
    }

    arm.progress += dt * (arm.state==='gripping'?2.5:1.4);
    const p = Math.min(arm.progress,1);

    if(arm.state==='reaching'){
      // Arm swings over belt to grab the sheet
      const reachAngle = (arm.lineIdx===0 ? 0.8 : -0.8);
      arm.upperArm.rotation.z = arm.restRotZ + reachAngle * p;
      arm.upperArm.rotation.x = arm.restRotX - 0.5*p;
      arm.foreArm.rotation.x = -0.3 - 0.6*p;
      arm.gripperGrp.children.forEach((f,i)=>{f.position.x=(i===0?-1:1)*0.09;});
      if(p>=1){arm.state='gripping';arm.progress=0;}
    }
    else if(arm.state==='gripping'){
      // Gripper closes
      arm.gripperGrp.children.forEach((f,i)=>{
        f.position.x=(i===0?-1:1)*Math.max(0.02,0.09-p*0.07);
      });
      if(p>=1){
        arm.gripping=true;arm.state='lifting';arm.progress=0;
        // Light flash on gripper
        arm.gripperGrp.children.forEach(f=>{
          f.material=new THREE.MeshStandardMaterial({color:0xff4400,emissive:0x441100,emissiveIntensity:0.6,roughness:0.5});
        });
      }
    }
    else if(arm.state==='lifting'){
      // Lift up
      arm.upperArm.rotation.x = (arm.restRotX-0.5) + 0.7*p;
      arm.foreArm.rotation.x = -0.9 + 0.5*p;
      // Move target sheet with arm
      if(arm.targetSheet&&!arm.targetSheet.done){
        arm.targetSheet.mesh.position.y = BELT_Y+0.065 + p*1.8;
        arm.targetSheet.mesh.position.x = arm.baseX + p*(arm.binX-arm.baseX)*0.3;
      }
      if(p>=1){arm.state='depositing';arm.progress=0;}
    }
    else if(arm.state==='depositing'){
      // Swing to bin and deposit
      const leanDir=(arm.lineIdx===0?1:-1);
      arm.upperArm.rotation.z = arm.restRotZ + (0.8+leanDir*0.6)*p;
      arm.upperArm.rotation.x = 0.2;
      if(arm.targetSheet&&!arm.targetSheet.done){
        arm.targetSheet.mesh.position.x = arm.baseX + p*(arm.binX-arm.baseX);
        arm.targetSheet.mesh.position.z = LINE_Z[arm.lineIdx] + p*((arm.lineIdx===0?2.8:-2.8)-LINE_Z[arm.lineIdx]);
        arm.targetSheet.mesh.position.y = BELT_Y+1.8 - p*1.4;
      }
      if(p>=1){
        // Drop sheet into bin
        if(arm.targetSheet){
          scene.remove(arm.targetSheet.mesh);
          if(arm.targetSheet.defectMesh) scene.remove(arm.targetSheet.defectMesh);
          arm.targetSheet.done=true;
        }
        arm.gripping=false;
        arm.gripperGrp.children.forEach(f=>{
          f.material=new THREE.MeshStandardMaterial({color:0x1e3a5a,roughness:0.4,metalness:0.75});
          f.position.x=f.position.x>0?0.09:-0.09;
        });
        arm.state='returning';arm.progress=0;arm.targetSheet=null;
      }
    }
    else if(arm.state==='returning'){
      // Return to idle rest pose
      arm.upperArm.rotation.z = THREE.MathUtils.lerp(arm.upperArm.rotation.z, arm.restRotZ, p*0.05+dt*2);
      arm.upperArm.rotation.x = THREE.MathUtils.lerp(arm.upperArm.rotation.x, arm.restRotX, p*0.05+dt*2);
      arm.foreArm.rotation.x = THREE.MathUtils.lerp(arm.foreArm.rotation.x, -0.3, p*0.05+dt*2);
      if(p>=1){arm.state='idle';arm.progress=0;}
    }
  });

  // Machine beacons
  machineLEDs.forEach((led,i)=>{
    const t=Date.now()*0.0016+i*1.5;
    led.material.emissiveIntensity=1.0+Math.sin(t)*0.8;
  });

  // Defect marker float
  [...sheetsByLine[0],...sheetsByLine[1]].forEach(s=>{
    if(s.defectMesh){
      s.defectMesh.position.x=s.mesh.position.x;
      s.defectMesh.position.z=s.mesh.position.z;
      s.defectMesh.rotation.y+=0.022;
      s.defectMesh.position.y=BELT_Y+0.55+Math.sin(Date.now()*0.004+s.id)*0.09;
    }
  });
}

function triggerDetector(det,sheet){
  if(det.busy)return;
  det.busy=true;det.scanning=true;det.scanProgress=0;det.beamAlpha=0;
  det.beamPlanes.forEach(bp=>bp.material.color.setHex(0x44aaff));
  det.beamLight.color.setHex(0x44aaff);
  const faultRate=parseInt(document.getElementById('frt').value)/100;
  const isDefect=(forceFault&&(forceFaultLine===-1||forceFaultLine===det.li))||Math.random()<faultRate;
  if(isDefect&&forceFault)forceFault=false;
  const defectType=isDefect?Math.floor(Math.random()*DEFECTS.length):null;
  det.result={sheet,isDefect,defectType};
}

function addDefectMarker(sheet){
  const def=DEFECTS[sheet.defectType];
  const geo=new THREE.OctahedronGeometry(0.14,0);
  const col=new THREE.Color(def.hex);
  const mat=new THREE.MeshStandardMaterial({color:col,emissive:col,emissiveIntensity:2.2,roughness:0.2,metalness:0,transparent:true,opacity:0.9});
  const mesh=new THREE.Mesh(geo,mat);
  mesh.position.set(sheet.mesh.position.x,BELT_Y+0.5,LINE_Z[sheet.lineIdx]);
  scene.add(mesh);sheet.defectMesh=mesh;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// HUD
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateHUD(){
  document.getElementById('h-scan').textContent=totScan;
  document.getElementById('h-def').textContent=totDef;
  document.getElementById('h-pass').textContent=totPass;
  document.getElementById('h-rate').textContent=totScan>0?Math.round(totDef/totScan*100)+'%':'‚Äî';
  document.getElementById('fault-badge').textContent=`${totDef} active fault${totDef!==1?'s':''}`;
}

function logDefect(sheet,det){
  const m=MACHINE_DATA[sheet.sourceMachine];
  const d=DEFECTS[sheet.defectType];
  const now=new Date();
  const ts=`${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}`;
  defectCount++;
  const body=document.getElementById('defect-log');
  const empty=body.querySelector('.empty-log');if(empty)empty.remove();
  const card=document.createElement('div');
  card.className='defect-card';
  card.innerHTML=`
    <div class="dc-row">
      <span class="dc-machine">${m.id} ¬∑ Line ${det.li+1}</span>
      <span class="dc-time">${ts}</span>
    </div>
    <div class="dc-type" style="color:${d.hex}">${d.name}</div>
    <div class="dc-desc">${d.desc}</div>
    <div class="dc-scanner">‚Ü≥ Scanner S-${det.di+1} ¬∑ Gantry ${det.di+1}</div>
  `;
  body.insertBefore(card,body.firstChild);
  while(body.children.length>35)body.removeChild(body.lastChild);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// CONTROLS
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function toggleSim(){simRunning=!simRunning;document.getElementById('tog').textContent=simRunning?'‚è∏ PAUSE':'‚ñ∂ RESUME';}
function injectFault(){forceFault=true;forceFaultLine=-1;}
function resetSim(){
  [...sheetsByLine[0],...sheetsByLine[1]].forEach(s=>{scene.remove(s.mesh);if(s.defectMesh)scene.remove(s.defectMesh);});
  sheetsByLine=[[],[]];spawnTimers=[0,0];
  particlePool.forEach(p=>scene.remove(p.mesh));particlePool.length=0;
  totScan=0;totDef=0;totPass=0;defectCount=0;machineDefects.fill(0);
  machineLabels.forEach((ml,i)=>{
    ml.defects=0;ml.updateLabel(0);
    machineCards[i].querySelector('.mc-faults').style.color='var(--green)';
    machineCards[i].querySelector('.mc-faults').textContent='0 faults';
    machineCards[i].classList.remove('has-fault');
  });
  detectorSets.forEach(det=>{
    det.scanning=false;det.busy=false;det.flash=0;
    det.beamPlanes.forEach(bp=>bp.material.opacity=0);
    det.beamLight.intensity=0;det.result=null;det.beamAlpha=0;det.scanProgress=0;
    det.statusLeds[0].material.emissiveIntensity=1.8;
    det.statusLeds[1].material.emissiveIntensity=0.15;
    det.statusLeds[2].material.emissiveIntensity=0.15;
  });
  robotArms.forEach(arm=>{arm.state='idle';arm.progress=0;arm.targetSheet=null;arm.gripping=false;});
  updateHUD();
  document.getElementById('fault-badge').textContent='0 active faults';
  document.getElementById('defect-log').innerHTML='<div class="empty-log">System nominal.<br>Awaiting inspection data.</div>';
}

document.getElementById('spd').addEventListener('input',function(){document.getElementById('spd-v').textContent=this.value+'√ó';});
document.getElementById('frt').addEventListener('input',function(){document.getElementById('frt-v').textContent=this.value+'%';});
setInterval(()=>{document.getElementById('clock-display').textContent=new Date().toTimeString().slice(0,8);},1000);
document.getElementById('clock-display').textContent=new Date().toTimeString().slice(0,8);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// RENDER LOOP
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function animate(){
  requestAnimationFrame(animate);
  const dt=Math.min(clock3.getDelta(),0.05);
  camera.position.x=camTarget.x+camR*Math.sin(camTheta)*Math.cos(camPhi);
  camera.position.y=camTarget.y+camR*Math.sin(camPhi);
  camera.position.z=camTarget.z+camR*Math.cos(camTheta)*Math.cos(camPhi);
  camera.lookAt(camTarget);
  update(dt);
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
